{
    Copyright (C) 2024 VCC
    creation date: 26 Sep 2023
    initial release date: 24 Mar 2024

    author: VCC
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
    OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
}


program MQTTClientApp;

uses
  MQTTUtils, MQTTClient;
  
  
type
  PSOCKET_Intern_Dsc = ^SOCKET_Intern_Dsc;


var
  MQTTToEthFIFO: TDynArrayOfTDynArrayOfByte;
  EthToMQTTFIFO: TDynArrayOfTDynArrayOfByte;
  RecFIFO: TDynArrayOfByte;  //filled in by Eth handler with raw data
  
const
  HEAP_START: DWord = $A0000FDC;
  HEAP_SIZE: DWord = 40000;

var
  SomeCondition: Boolean;
  MainCounter: Byte;
  Xcoord, Ycoord: Word;

var
  MyMacAddr   : array[6] of byte; // my MAC address
  MyIpAddr    : array[4] of byte; // my IP address
  GWIpAddr    : array[4] of byte; // gateway (router) IP address
  IpMask      : array[4] of byte; // network mask (for example : 255.255.255.0)
  DnsIpAddr   : array[4] of byte; // DNS server IP address

//Parts of the code come from mikromedia example. Other parts are generated by mikroPascal.

// TFT module connections
var //TFT_BLED_Direction : sbit  at TRISC2_bit;
    //TFT_BLED : sbit  at LATC2_bit;
    TFT_CS_Direction : sbit  at TRISF12_bit;
    TFT_CS : sbit  at LATF12_bit;
    TFT_DataPort_Direction : word  at TRISE;
    TFT_DataPort : word  at LATE;
    TFT_RD_Direction : sbit  at TRISD5_bit;
    TFT_RD : sbit  at LATD5_bit;
    TFT_RS_Direction : sbit  at TRISB15_bit;
    TFT_RS : sbit  at LATB15_bit;
    TFT_RST_Direction : sbit  at TRISC1_bit;
    TFT_RST : sbit  at LATC1_bit;
    TFT_WR_Direction : sbit  at TRISD4_bit;
    TFT_WR : sbit  at LATD4_bit;
// End TFT module connections

  LED_R: sbit at LATD.1;
  LED_G: sbit at LATD.2;
  LED_B: sbit at LATD.3;

  LED_G_On: bit;

  UpdateSeconds: Boolean;
  Net_Ethernet_Intern_UserTimerSec_5s: Byte;
  HasDataToSend: Boolean;
  
  
procedure PMPWaitBusy();
begin
  while(PMMODE.BUSY = 1) do ;
end;


procedure Set_Index(index : byte);
begin
  TFT_RS := 0;
  PMDIN := index;
  PMPWaitBusy();
end;

procedure Write_Command(cmd : byte);
begin
  TFT_RS := 1;
  PMDIN := cmd;
  PMPWaitBusy();
end;

procedure Write_Data(_data : word);
begin
  TFT_RS := 1;
  PMDIN := _data;
  PMPWaitBusy();
end;


procedure InitializeTouchPanel(); // static
begin
  TFT_Set_Active(@Set_Index, @Write_Command, @Write_Data);
  TFT_Init_SSD1963(480, 272);
  TFT_Set_DBC_SSD1963(50);
end;


procedure Calibrate();
begin
  TFT_Fill_Screen(CL_BLACK);
  TFT_Set_Font(@TFT_defaultFont, CL_WHITE, FO_HORIZONTAL);
  TFT_Write_Text('Touch points on the screen as they', 125, 121);
  TFT_Write_Text('appear to calibrate touchscreen.', 135, 151);
  STMPE610_ClearInterruptFlagsAndFIFO();
  TFT_Set_Brush(1, CL_WHITE, 0, 0, 0, 0);
  TFT_Circle(0, 0, 3);
  STMPE610_CalibratePoint(STMPE610_FIRST_CORNER);
  Delay_ms(500);
  TFT_Set_Brush(1, CL_BLACK, 0, 0, 0, 0);
  TFT_Circle(0, 0, 3);
  STMPE610_ClearInterruptFlagsAndFIFO();
  TFT_Set_Brush(1, CL_WHITE, 0, 0, 0, 0);
  TFT_Circle(0, TFT_DISP_HEIGHT-1, 3);
  STMPE610_CalibratePoint(STMPE610_SECOND_CORNER);
  Delay_ms(500);
  TFT_Set_Brush(1, CL_BLACK, 0, 0, 0, 0);
  TFT_Circle(0, TFT_DISP_HEIGHT-1, 3);
  STMPE610_ClearInterruptFlagsAndFIFO();
  TFT_Set_Brush(1, CL_WHITE, 0, 0, 0, 0);
  TFT_Circle(TFT_DISP_WIDTH-1, TFT_DISP_HEIGHT-1, 3);
  STMPE610_CalibratePoint(STMPE610_THIRD_CORNER);
  Delay_ms(500);
  TFT_Set_Brush(1, CL_BLACK, 0, 0, 0, 0);
  TFT_Circle(TFT_DISP_WIDTH-1, TFT_DISP_HEIGHT-1, 3);
  STMPE610_ClearInterruptFlagsAndFIFO();
  TFT_Set_Brush(1, CL_WHITE, 0, 0, 0, 0);
  TFT_Circle(TFT_DISP_WIDTH-1, 0, 3);
  STMPE610_CalibratePoint(STMPE610_FOURTH_CORNER);
  TFT_Set_Brush(1, CL_BLACK, 0, 0, 0, 0);
  TFT_Circle(TFT_DISP_WIDTH-1, 0, 3);
  Delay_ms(500);
end;


procedure Check_TP();       /////////////////////////////////////////////////////////////////////////////////////
begin
  {if (STMPE610_PressDetect()) then
  begin
    if (STMPE610_GetLastCoordinates(@Xcoord, @Ycoord) = 0) then
    begin
      DynTFTMCU_OldXMouse := DynTFTMCU_XMouse;
      DynTFTMCU_OldYMouse := DynTFTMCU_YMouse;
      DynTFTMCU_XMouse := Xcoord;
      DynTFTMCU_YMouse := Ycoord;
      DynTFTReceivedMouseDown := True;
    end;
  end
  else
  begin
    DynTFTMCU_XMouse := Xcoord;
    DynTFTMCU_YMouse := Ycoord;
    DynTFTReceivedMouseUp := True;
  end; }
end;


//Timer1 and PHY code from mikroe example
procedure Timer1Init;
begin
  TMR1 := 0;                 // reset timer value to zero
  PR1 := 65535;              // Load period register

  T1IP0_bit := 1;            // set interrupt
  T1IP1_bit := 1;            // priority
  T1IP2_bit := 1;            // to 7

  TCKPS0_bit := 1;           // Set Timer Input Clock
  TCKPS1_bit := 1;           // Prescale value to 1:256
  EnableInterrupts();        // Enable all interrupts

  T1IE_bit := 1;             // Enable Timer1 Interrupt
  ON__T1CON_bit := 1;        // Enable Timer1
end;

var
  timer_tmp1: Byte;

procedure Timer1Int; iv IVT_TIMER_1; ilevel 7; ics ICS_SRS;
begin
  Inc(timer_tmp1);
  if timer_tmp1 = 5 then
  begin //1s
    timer_tmp1 := 0;
    Net_Ethernet_Intern_UserTimerSec := Net_Ethernet_Intern_UserTimerSec + 1;
    UpdateSeconds := True;

    Inc(Net_Ethernet_Intern_UserTimerSec_5s);
    if Net_Ethernet_Intern_UserTimerSec_5s > 4 then
    begin
      Net_Ethernet_Intern_UserTimerSec_5s := 0;
      //ShouldCheckEthConnection := True;
    end;
  end;

  if LED_G = 1 then
  begin
    if LED_G_On = 0 then
      LED_G_On := 1
    else
    begin
      LED_G := 0;
      LED_G_On := 0;
    end;
  end;

  TMR1 := 0;
  T1IF_bit := 0; // clear interrupt flag
end;

  
procedure InitPHYPins;
begin
  TRISD11_bit := 0;   // ETH_ALT_MDC_BIT
  TRISD8_bit := 1;    // ETH_ALT_MDIO_BIT

  TRISA15_bit := 0;   // ETH_ALT_TXEN_BIT
  TRISD14_bit := 0;   // ETH_ALT_TXD0_BIT
  TRISD15_bit := 0;   // ETH_ALT_TXD1_BIT

  TRISG9_bit := 1;    // ETH_ALT_RXCLK_BIT
  TRISG8_bit := 1;    // ETH_ALT_RXDV_BIT
  TRISE8_bit := 1;    // ETH_ALT_RXD0_BIT
  TRISE9_bit := 1;    // ETH_ALT_RXD1_BIT
  TRISG15_bit:= 1;    // ETH_ALT_RXERR_BIT
end;


procedure InitRGBLED;
begin
  TRISD.1 := 0;
  TRISD.2 := 0;
  TRISD.3 := 0;
  LED_R := 0;
  LED_G := 0;
  LED_B := 0;
end;


procedure Init_MCU;
begin
  AD1PCFG := 0xFFFF;
  JTAGEN_bit := 0;
  // If bus is busy wait SDA high before initializing I2C module
  TRISA2_bit := 0;
  TRISA3_bit := 1;
  LATA2_bit := 1;
  while (PORTA.B3 = 0) do
  begin
    LATA2_bit := 0;
    Delay_us(10);
    LATA2_bit := 1;
    Delay_us(10);
  end;

  InitRGBLED;

  I2C2_Init(100000);
  // PMP setup
  PMMODE := 0;
  // PMAEN: Parallel Master Port Address Enable Register
  PMAEN  := 0;  // pins used as normal I/O
  PMCON  := 0;  // WRSP: Write Strobe Polarity bit
  PMMODE := 0;
  PMAEN := 0;
  PMCON := 0;
  PMMODE := 0x0604;
  PMCON := 0x8300;
  TFT_Set_Default_Mode();
  STMPE610_SetDefaultMode();
  TFT_Set_MM_Plus();

  MainCounter := 0;
  LED_G_On := 0;

  Timer1Init;
  InitPHYPins;
  //EthConnected := False;

  //ShouldCheckEthConnection := False;
  Net_Ethernet_Intern_UserTimerSec_5s := 0;
  HasDataToSend := False;
end;


function STMPE610_Config: Byte;
begin
  STMPE610_SetI2CAddress(STMPE610_I2C_ADDR1);
  if (STMPE610_IsOperational() <> 0) then
  begin
    Result := STMPE610_IO_NOT_OPERATIONAL;
    Exit;
  end;

  STMPE610_Reset();
  STMPE610_Module(STMPE610_MODULE_TS or STMPE610_MODULE_ADC, STMPE610_ENABLE);
  STMPE610_AlternateFunction(STMPE610_GPIO_PIN1, STMPE610_ENABLE);
  STMPE610_SetGPIOPin(STMPE610_GPIO_PIN1, 0);   // IN1 to "0" -> I2C communication
  STMPE610_SetSize(480,272);
  STMPE610_Module(STMPE610_MODULE_TS or STMPE610_MODULE_ADC, STMPE610_ENABLE);
  STMPE610_EnableInterrupt(0, STMPE610_ENABLE);
  STMPE610_ConfigureInterrupt(STMPE610_INT_POLARITY_ACTIVE_HIGH or STMPE610_INT_TYPE_EDGE or STMPE610_INT_ENABLE_ALL);
  STMPE610_SetADC(STMPE610_ADC_CTRL1_SAMPLETIME_56 or STMPE610_ADC_CTRL1_ADC_12BIT or STMPE610_ADC_CTRL1_INT_REFERENCE);
  Delay_10ms(); Delay_10ms();
  STMPE610_SetADCClock(STMPE610_ADC_CTRL2_3250_kHZ);
  STMPE610_AlternateFunction(STMPE610_GPIO_PIN4 or STMPE610_GPIO_PIN5 or STMPE610_GPIO_PIN6 or STMPE610_GPIO_PIN7, STMPE610_DISABLE);
  STMPE610_ConfigureTSC(STMPE610_TSC_CFG_AVE_CTRL_4S, STMPE610_TSC_CFG_TOUCH_DET_DELAY_500uS, STMPE610_TSC_CFG_TOUCH_SETTLING_1mS);
  STMPE610_SetFIFOThreshold(1);
  STMPE610_ResetFIFO();
  STMPE610_TSIDrive(STMPE610_TSC_I_DRIVE_20mA);
  STMPE610_TSControl(STMPE610_TSC_CTRL_TRACK0 or STMPE610_TSC_CTRL_ACQU_XYZ or STMPE610_TSC_CTRL_ENABLE);
  STMPE610_ZDataFraction(STMPE610_FRACP4_WHOLP4);
  STMPE610_SetTouchPressureThreshold(70);
  STMPE610_ClearInterrupts();
  STMPE610_WriteReg(STMPE610_INT_CTRL_REG, 0x01);
  Result := STMPE610_OK;
end;
  

procedure AddToLog(var AMsg: string[100000]);
begin
  //UART1_Write_Text(AMsg);
end;


procedure SendPacketToServer(ClientInstance: DWord);
var
  BufferPointer: PMQTTBuffer;
  Err: Word;
begin
  BufferPointer := MQTT_GetClientToServerBuffer(ClientInstance, Err){$IFnDEF SingleOutputBuffer}^.Content^[0]{$ENDIF};

  if not AddDynArrayOfByteToDynOfDynOfByte(MQTTToEthFIFO, BufferPointer^) then
    AddToLog('Not enough memory in SendPacketToServer');

  {$IFnDEF SingleOutputBuffer}
    if not MQTT_RemovePacketFromClientToServerBuffer(ClientInstance) then
      AddToLog('Can''t remove latest packet from send buffer.');
  {$ELSE}
    AddToLog('MQTT_RemovePacketFromClientToServerBuffer not implemented for SingleOutputBuffer.');
  {$ENDIF}
end;


procedure HandleOnMQTTError(ClientInstance: DWord; AErr: Word; APacketType: Byte);
var
  PacketTypeStr: string[13];
begin
  MQTTPacketToString(APacketType, PacketTypeStr);
  AddToLog('  PacketType: (' + PacketTypeStr + ').');

  if Hi(AErr) = CMQTT_Reason_NotAuthorized then   // $87
  begin
    AddToLog('Server error: Not authorized.');
    if APacketType = CMQTT_CONNACK then
      AddToLog(' on receiving CONNACK.');
  end;

  if Lo(AErr) = CMQTT_PacketIdentifierNotFound_ClientToServer then   // $CE
    AddToLog('Client error: PacketIdentifierNotFound.');
    
  if Lo(AErr) = CMQTT_UnhandledPacketType then   // $CA
    AddToLog('Client error: UnhandledPacketType.');  //Usually appears when an incomplete packet is received, so the packet type by is 0.
    
  if Lo(AErr) = CMQTT_OutOfMemory then
    LED_R := 1;
end;


procedure HandleOnSend_MQTT_Packet(ClientInstance: DWord; APacketType: Byte);
var
  PacketName: string[13];
begin
  MQTTPacketToString(APacketType, PacketName);
  AddToLog('Sending ' + PacketName + ' packet...');

  SendPacketToServer(ClientInstance);
end;


function HandleOnBeforeMQTT_CONNECT(ClientInstance: DWord;  //The lower byte identifies the client instance (the library is able to implement multiple MQTT clients / device). The higher byte can identify the call in user handlers for various events (e.g. TOnBeforeMQTT_CONNECT).
                                    var AConnectFields: TMQTTConnectFields;                    //user code has to fill-in this parameter
                                    var AConnectProperties: TMQTTConnectProperties;
                                    ACallbackID: Word): Boolean;
var
  TempWillProperties: TMQTTWillProperties;
  UserName, Password: string[30];
  //ClientId: string;
  //Id: Char;
  ConnectFlags: Byte;
  EnabledProperties: Word;
begin
  Result := True;
  AddToLog('Preparing CONNECT data..');

  //Id := Chr((ClientInstance and $FF) + 48);
  //ClientId := 'MyClient' + Id;
  UserName := ''; //'MyUsername';
  Password := ''; //'MyPassword';

  //StringToDynArrayOfByte(ClientId, AConnectFields.PayloadContent.ClientID);
  StringToDynArrayOfByte(UserName, AConnectFields.PayloadContent.UserName);
  StringToDynArrayOfByte(Password, AConnectFields.PayloadContent.Password);

  ConnectFlags := CMQTT_UsernameInConnectFlagsBitMask or
                  CMQTT_PasswordInConnectFlagsBitMask or
                  CMQTT_CleanStartInConnectFlagsBitMask {or
                  CMQTT_WillQoSB1InConnectFlagsBitMask};

  EnabledProperties := CMQTTConnect_EnSessionExpiryInterval or
                       CMQTTConnect_EnRequestResponseInformation or
                       CMQTTConnect_EnRequestProblemInformation {or
                       CMQTTConnect_EnAuthenticationMethod or
                       CMQTTConnect_EnAuthenticationData};

  MQTT_InitWillProperties(TempWillProperties);
  TempWillProperties.WillDelayInterval := 30; //some value
  TempWillProperties.PayloadFormatIndicator := 1;  //0 = do not send.  1 = UTF-8 string
  TempWillProperties.MessageExpiryInterval := 3600;
  StringToDynArrayOfByte('SomeType', TempWillProperties.ContentType);
  StringToDynArrayOfByte('SomeTopicName', TempWillProperties.ResponseTopic);
  StringToDynArrayOfByte('MyCorrelationData', TempWillProperties.CorrelationData);
  
  {$IFDEF EnUserProperty}
    AddStringToDynOfDynArrayOfByte('Key=Value', TempWillProperties.UserProperty);
    AddStringToDynOfDynArrayOfByte('NewKey=NewValue', TempWillProperties.UserProperty);
  {$ENDIF}

  FillIn_PayloadWillProperties(TempWillProperties, AConnectFields.PayloadContent.WillProperties);
  MQTT_FreeWillProperties(TempWillProperties);
  StringToDynArrayOfByte('WillTopic', AConnectFields.PayloadContent.WillTopic);

  //Please set the Will Flag in ConnectFlags below, then uncomment above code, if "Will" properties are required.
  AConnectFields.ConnectFlags := ConnectFlags;  //bits 7-0:  User Name, Password, Will Retain, Will QoS, Will Flag, Clean Start, Reserved
  AConnectFields.EnabledProperties := EnabledProperties;
  AConnectFields.KeepAlive := 0; //any positive values require pinging the server if no other packet is being sent

  AConnectProperties.SessionExpiryInterval := 3600; //[s]
  AConnectProperties.ReceiveMaximum := 7000;
  AConnectProperties.MaximumPacketSize := 10 * 1024 * 1024;
  AConnectProperties.TopicAliasMaximum := 100;
  AConnectProperties.RequestResponseInformation := 1;
  AConnectProperties.RequestProblemInformation := 1;
  
  {$IFDEF EnUserProperty}
    AddStringToDynOfDynArrayOfByte('UserProp=Value', AConnectProperties.UserProperty);
  {$ENDIF}
  
  StringToDynArrayOfByte('SCRAM-SHA-1', AConnectProperties.AuthenticationMethod);       //some example from spec, pag 108   the server may add to its log: "bad AUTH method"
  StringToDynArrayOfByte('client-first-data', AConnectProperties.AuthenticationData);   //some example from spec, pag 108

  AddToLog('Done preparing CONNECT data..');
  AddToLog('');
end;


procedure HandleOnAfterMQTT_CONNACK(ClientInstance: DWord; var AConnAckFields: TMQTTConnAckFields; var AConnAckProperties: TMQTTConnAckProperties);
var
  n, i: Integer;
begin
  AddToLog('Received CONNACK');

end;


function HandleOnBeforeSendingMQTT_SUBSCRIBE(ClientInstance: DWord;  //The lower word identifies the client instance
                                             var ASubscribeFields: TMQTTSubscribeFields;
                                             var ASubscribeProperties: TMQTTSubscribeProperties;
                                             ACallbackID: Word): Boolean;
var
  Options, QoS: Byte;
  SubId: Word;
begin
  Options := 0;
  QoS := 2;

  Options := Options or QoS; //bits 1 and 0
  //Bit 2 of the Subscription Options represents the No Local option.  - spec pag 73
  //Bit 3 of the Subscription Options represents the Retain As Published option.  - spec pag 73
  //Bits 4 and 5 of the Subscription Options represent the Retain Handling option.  - spec pag 73
  //Bits 6 and 7 of the Subscription Options byte are reserved for future use. - Must be set to 0.  - spec pag 73

                                                                            //Subscription identifiers are not mandatory (per spec).
  SubId := MQTT_CreateClientToServerSubscriptionIdentifier(ClientInstance); //This function has to be called here, in this handler only. The library does not call this function other than for init purposes.
                                                                            //If SubscriptionIdentifiers are used, then user code should free them when resubscribing or when unsubscribing.
  ASubscribeProperties.SubscriptionIdentifier := SubId;  //For now, the user code should keep track of these identifiers and free them on resubscribing or unsubscribing.

  Result := FillIn_SubscribePayload('abc', Options, ASubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to ASubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_SUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  //Enable SubscriptionIdentifier only if required (allocated above with CreateClientToServerSubscriptionIdentifier) !!!
  //The library initializes EnabledProperties to 0.
  //A subscription is allowed to be made without a SubscriptionIdentifier.
  ASubscribeFields.EnabledProperties := CMQTTSubscribe_EnSubscriptionIdentifier {or CMQTTSubscribe_EnUserProperty};

  AddToLog('');
end;


procedure HandleOnAfterReceivingMQTT_SUBACK(ClientInstance: DWord; var ASubAckFields: TMQTTSubAckFields; var ASubAckProperties: TMQTTSubAckProperties);
var
  i: Integer;
begin
  AddToLog('Received SUBACK');

  AddToLog('');
end;


function HandleOnBeforeSendingMQTT_UNSUBSCRIBE(ClientInstance: DWord;  //The lower word identifies the client instance
                                               var AUnsubscribeFields: TMQTTUnsubscribeFields;
                                               var AUnsubscribeProperties: TMQTTUnsubscribeProperties;
                                               ACallbackID: Word): Boolean;
begin
  Result := FillIn_UnsubscribePayload('abc', AUnsubscribeFields.TopicFilters);  //call this again with a different string (i.e. TopicFilter), in order to add it to AUnsubscribeFields.TopicFilters
  if not Result then
  begin
    AddToLog('HandleOnBeforeSendingMQTT_UNSUBSCRIBE not enough memory to add TopicFilters.');
    Exit;
  end;

  //the user code should call RemoveClientToServerSubscriptionIdentifier to remove the allocate identifier.
end;


procedure HandleOnAfterReceivingMQTT_UNSUBACK(ClientInstance: DWord; var AUnsubAckFields: TMQTTUnsubAckFields; var AUnsubAckProperties: TMQTTUnsubAckProperties);
var
  i: Integer;
begin
  AddToLog('Received UNSUBACK');

  AddToLog('');
end;


//This handler is used when this client publishes a message to broker.
function HandleOnBeforeSendingMQTT_PUBLISH(ClientInstance: DWord;  //The lower word identifies the client instance (the library is able to implement multiple MQTT clients / device). The higher byte can identify the call in user handlers for various events (e.g. TOnBeforeMQTT_CONNECT).
                                           var APublishFields: TMQTTPublishFields;                    //user code has to fill-in this parameter
                                           var APublishProperties: TMQTTPublishProperties;            //user code has to fill-in this parameter
                                           ACallbackID: Word): Boolean;
var
  Msg: string[20];
  QoS: Byte;
begin
  Result := True;
  Msg := 'SomeMessage';

  QoS := 2;

  Result := Result and StringToDynArrayOfByte(Msg, APublishFields.ApplicationMessage);
  Result := Result and StringToDynArrayOfByte('abc', APublishFields.TopicName);

  AddToLog('');
  //QoS can be overriden here. If users override QoS in this handler, then a a different PacketIdentifier might be allocated (depending on what is available)
end;


//This handler is used when this client publishes a message to broker and the broker responds with PUBACK.
procedure HandleOnBeforeSendingMQTT_PUBACK(ClientInstance: DWord; var APubAckFields: TMQTTPubAckFields; var APubAckProperties: TMQTTPubAckProperties);
begin
  AddToLog('Acknowledging with PUBACK');

  AddToLog('');
  //This handler can be used to override what is being sent to server as a reply to PUBLISH
end;


procedure HandleOnAfterReceivingMQTT_PUBACK(ClientInstance: DWord; var APubAckFields: TMQTTPubAckFields; var APubAckProperties: TMQTTPubAckProperties);
begin
  AddToLog('Received PUBACK');

  AddToLog('');
end;


procedure HandleOnAfterReceivingMQTT_PUBLISH(ClientInstance: DWord; var APublishFields: TMQTTPublishFields; var APublishProperties: TMQTTPublishProperties);
var
  QoS: Byte;
  ID: Word;
  Topic, Msg: string[300];
  IDstr: string[6];
  QoSStr: string[3];
  i: Integer;
begin
  QoS := (APublishFields.PublishCtrlFlags shr 1) and 3;
  ByteToStr(QoS, QoSStr);
  DynArrayOfByteToString(APublishFields.ApplicationMessage, Msg);
  
  ID := APublishFields.PacketIdentifier;
  WordToStr(ID, IDstr);
  
  DynArrayOfByteToString(APublishFields.TopicName, Topic);

  AddToLog('Received PUBLISH  ServerPacketIdentifier: ' + IDstr +
                                                 '  Msg: ' + Msg +
                                                 '  QoS: ' + QoSStr +
                                                 '  TopicName: ' + Topic);

  AddToLog('');
end;


procedure HandleOnBeforeSending_MQTT_PUBREC(ClientInstance: DWord; var ATempPubRecFields: TMQTTPubRecFields; var ATempPubRecProperties: TMQTTPubRecProperties);
begin
  AddToLog('Acknowledging with PUBREC');
end;


procedure HandleOnAfterReceiving_MQTT_PUBREC(ClientInstance: DWord; var ATempPubRecFields: TMQTTPubRecFields; var ATempPubRecProperties: TMQTTPubRecProperties);
begin
  AddToLog('Received PUBREC' );
end;


//Sending PUBREL after the PUBREC response from server, after the client has sent a PUBLISH packet with QoS=2.
procedure HandleOnBeforeSending_MQTT_PUBREL(ClientInstance: DWord; var ATempPubRelFields: TMQTTPubRelFields; var ATempPubRelProperties: TMQTTPubRelProperties);
begin
  AddToLog('Acknowledging with PUBREL');
end;


procedure HandleOnAfterReceiving_MQTT_PUBREL(ClientInstance: DWord; var ATempPubRelFields: TMQTTPubRelFields; var ATempPubRelProperties: TMQTTPubRelProperties);
begin
  AddToLog('Received PUBREL');
end;


procedure HandleOnBeforeSending_MQTT_PUBCOMP(ClientInstance: DWord; var ATempPubCompFields: TMQTTPubCompFields; var ATempPubCompProperties: TMQTTPubCompProperties);
begin
  AddToLog('Acknowledging with PUBCOMP');
end;


procedure HandleOnAfterReceiving_MQTT_PUBCOMP(ClientInstance: DWord; var ATempPubCompFields: TMQTTPubCompFields; var ATempPubCompProperties: TMQTTPubCompProperties);
begin
  AddToLog('Received PUBCOMP');
end;


procedure HandleOnAfterReceivingMQTT_PINGRESP(ClientInstance: DWord);
begin
  AddToLog('Received PINGRESP');
end;


procedure HandleOnBeforeSendingMQTT_DISCONNECT(ClientInstance: DWord;  //The lower word identifies the client instance
                                               var ADisconnectFields: TMQTTDisconnectFields;
                                               var ADisconnectProperties: TMQTTDisconnectProperties;
                                               ACallbackID: Word);
begin
  AddToLog('Sending DISCONNECT');
  //ADisconnectFields.EnabledProperties := CMQTTDisconnect_EnSessionExpiryInterval;   //uncomment if needed
  //ADisconnectProperties.SessionExpiryInterval := 1;
end;


procedure HandleOnAfterReceivingMQTT_DISCONNECT(ClientInstance: DWord;  //The lower word identifies the client instance
                                                var ADisconnectFields: TMQTTDisconnectFields;
                                                var ADisconnectProperties: TMQTTDisconnectProperties);
begin
  AddToLog('Received DISCONNECT');
end;


procedure HandleOnBeforeSendingMQTT_AUTH(ClientInstance: DWord;  //The lower word identifies the client instance
                                         var AAuthFields: TMQTTAuthFields;
                                         var AAuthProperties: TMQTTAuthProperties;
                                         ACallbackID: Word);
begin
  AddToLog('Sending AUTH');
  AAuthFields.AuthReasonCode := $19; //Example: reauth   - see spec, pag 108.

  StringToDynArrayOfByte('SCRAM-SHA-1', AAuthProperties.AuthenticationMethod);       //some example from spec, pag 108
  StringToDynArrayOfByte('client-second-data', AAuthProperties.AuthenticationData);   //some modified example from spec, pag 108
end;


procedure HandleOnAfterReceivingMQTT_AUTH(ClientInstance: DWord;  //The lower word identifies the client instance
                                          var AAuthFields: TMQTTAuthFields;
                                          var AAuthProperties: TMQTTAuthProperties);
begin
  AddToLog('Received AUTH');
end;


procedure SyncReceivedBuffer(var AReadBuf: TDynArrayOfByte);
begin
  if not AddDynArrayOfByteToDynOfDynOfByte(EthToMQTTFIFO, AReadBuf) then
    AddToLog('Out of memory on adding to ReceivedBuffer FIFO.');
end;


var
  TempReadBuf: TDynArrayOfByte;  //This is a global var on MCU, because Net_Ethernet_Intern_UserTCP adds to it over multiple calls.

procedure RecFIFOToMQTT;
var
  ExactPacket: TDynArrayOfByte;
  TempByte: Byte;
  PacketName: string[30];
  PacketSize: DWord;
  LoggedDisconnection: Boolean;
  TempArr: TDynArrayOfByte;
  SuccessfullyDecoded, SuccessfullyRead: Boolean;
  ProcessBufferLengthResult: Word;
begin
  //InitDynArrayToEmpty(TempReadBuf); //Do not initialize here! The content of this array is accumulated over multiple calls to Net_Ethernet_Intern_UserTCP
  SuccessfullyRead := False;
  repeat
    if RecFIFO.Len = 0 then    // An IOHandler.ReadByte call would throw an exception when attempting to read more that available.
      Exit;

    TempByte := RecFIFO.Content^[0];
    if not RemoveStartBytesFromDynArray(1, RecFIFO) then
    begin
      AddToLog('Out of memory when removing a byte from RecFIFO.');
      Exit;
    end;

    if not AddByteToDynArray(TempByte, TempReadBuf) then
    begin
      HandleOnMQTTError(0, CMQTT_UserError, CMQTT_UNDEFINED);
      AddToLog('Cannot allocate buffer when reading.');
      FreeDynArray(TempReadBuf);
    end
    else
    begin
      SuccessfullyDecoded := True;                                         //PacketSize should be the expected size, which can be greater than TempReadBuf.Len
      ProcessBufferLengthResult := MQTT_ProcessBufferLength(TempReadBuf, PacketSize);

      if ProcessBufferLengthResult <> CMQTTDecoderNoErr then
        SuccessfullyDecoded := False
      else
        if ProcessBufferLengthResult = CMQTTDecoderIncompleteBuffer then  //PacketSize is successfully decoded, but the packet is incomplete
        begin
          //to get a complete packet, the number of bytes to be read next is PacketSize - TempReadBuf.Len.

          if RecFIFO.Len < PacketSize - TempReadBuf.Len then    // An IOHandler.ReadBytes call would throw an exception when attempting to read more that available.
            Exit;

          InitDynArrayToEmpty(TempArr);
          CopyFromDynArray(TempArr, RecFIFO, 0, PacketSize - TempReadBuf.Len);

          if not RemoveStartBytesFromDynArray(TempArr.Len, RecFIFO) then
          begin
            AddToLog('Out of memory when removing a byte from RecFIFO.');
            Exit;
          end;

          if TempArr.Len > 0 then   //it should be >0, otherwise this loop wouldn't have been executed
            if not ConcatDynArrays(TempReadBuf, TempArr) then
            begin
              AddToLog('Out of memory on allocating TempReadBuf, for multiple bytes.');
              FreeDynArray(TempReadBuf);
            end
            else
            begin
              ProcessBufferLengthResult := MQTT_ProcessBufferLength(TempReadBuf, PacketSize);
              SuccessfullyDecoded := ProcessBufferLengthResult <> CMQTTDecoderNoErr;
            end;

          FreeDynArray(TempArr);
        end;

      if SuccessfullyDecoded then
      begin
        MQTTPacketToString(TempReadBuf.Content^[0], PacketName);
        AddToLog('done receiving packet:');
        AddToLog(PacketName);

        if PacketSize <> TempReadBuf.Len then
        begin
          if CopyFromDynArray(ExactPacket, TempReadBuf, 0, PacketSize) then
          begin
            SyncReceivedBuffer(ExactPacket);
            FreeDynArray(ExactPacket);
            if not RemoveStartBytesFromDynArray(PacketSize, TempReadBuf) then
              AddToLog('Cannot remove processed packet from TempReadBuf.');
          end
          else
            AddToLog('Out of memory on allocating ExactPacket.');
        end
        else
        begin
          SyncReceivedBuffer(TempReadBuf);   //MQTT_Process returns an error for unknown and incomplete packets
          FreeDynArray(TempReadBuf);   //freed here, only when a valid packet is formed
        end;

        //Sleep(1);
      end; //SuccessfullyDecoded
    end;

  until SuccessfullyRead;
end;


procedure Net_Ethernet_Intern_UserTCP(socket: PSOCKET_Intern_Dsc);   //callback for receiving data
var
  Arr: TDynArrayOfByte;
begin
  if socket^.dataLength > 0 then
  begin
    InitDynArrayToEmpty(Arr);
    if not SetDynLength(Arr, socket^.dataLength) then
    begin
      HandleOnMQTTError(socket^.ID, CMQTT_OutOfMemory, 0);
      Exit;
    end;

    Net_Ethernet_Intern_getBytes(PByte(Arr.Content), $FFFF, Arr.Len);

    if not ConcatDynArrays(RecFIFO, Arr) then
      HandleOnMQTTError(socket^.ID, CMQTT_OutOfMemory, 0);

    FreeDynArray(Arr);
    RecFIFOToMQTT;
  end;

  if MQTTToEthFIFO.Len > 0 then
    if Net_Ethernet_Intern_bufferEmptyTCP(@socket_Intern[0]) = 1 then //1 = buffer empty
    begin
      HasDataToSend := True;
      Net_Ethernet_Intern_putBytesTCP(DWord(MQTTToEthFIFO.Content^[0]^.Content), MQTTToEthFIFO.Content^[0]^.Len, @socket_Intern[0]);
      DeleteItemFromDynOfDynOfByte(MQTTToEthFIFO, 0);
    end;
end;


function Net_Ethernet_Intern_UserUDP(udpDsc: ^UDP_Intern_Dsc): Word;
begin
  Result := 0;
end;


procedure ProcessReceivedBuffer;  //called by a timer, or main loop, once in a while, to process received data
var
  TempReadBuf: TDynArrayOfByte;
begin
  if EthToMQTTFIFO.Len > 0 then
  begin
    InitDynArrayToEmpty(TempReadBuf);

    if MQTT_PutReceivedBufferToMQTTLib(0, EthToMQTTFIFO.Content^[0]^) then
    begin
      if not DeleteItemFromDynOfDynOfByte(EthToMQTTFIFO, 0) then
        AddToLog('Out of memory in ProcessReceivedBuffer.');

      MQTT_Process(0);
    end
    else
      AddToLog('Out of memory in ProcessReceivedBuffer.');

    FreeDynArray(TempReadBuf);
  end;
end;


procedure InitHandlers;
begin
  {$IFDEF IsDesktop}
    OnMQTTError^ := @HandleOnMQTTError;
    OnSendMQTT_Packet^ := @HandleOnSend_MQTT_Packet;
    OnBeforeMQTT_CONNECT^ := @HandleOnBeforeMQTT_CONNECT;
    OnAfterMQTT_CONNACK^ := @HandleOnAfterMQTT_CONNACK;
    OnBeforeSendingMQTT_PUBLISH^ := @HandleOnBeforeSendingMQTT_PUBLISH;
    OnBeforeSendingMQTT_PUBACK^ := @HandleOnBeforeSendingMQTT_PUBACK;
    OnAfterReceivingMQTT_PUBACK^ := @HandleOnAfterReceivingMQTT_PUBACK;
    OnAfterReceivingMQTT_PUBLISH^ := @HandleOnAfterReceivingMQTT_PUBLISH;
    OnBeforeSendingMQTT_PUBREC^ := @HandleOnBeforeSending_MQTT_PUBREC;
    OnAfterReceivingMQTT_PUBREC^ := @HandleOnAfterReceiving_MQTT_PUBREC;
    OnBeforeSendingMQTT_PUBREL^ := @HandleOnBeforeSending_MQTT_PUBREL;
    OnAfterReceivingMQTT_PUBREL^ := @HandleOnAfterReceiving_MQTT_PUBREL;
    OnBeforeSendingMQTT_PUBCOMP^ := @HandleOnBeforeSending_MQTT_PUBCOMP;
    OnAfterReceivingMQTT_PUBCOMP^ := @HandleOnAfterReceiving_MQTT_PUBCOMP;
    OnBeforeSendingMQTT_SUBSCRIBE^ := @HandleOnBeforeSendingMQTT_SUBSCRIBE;
    OnAfterReceivingMQTT_SUBACK^ := @HandleOnAfterReceivingMQTT_SUBACK;
    OnBeforeSendingMQTT_UNSUBSCRIBE^ := @HandleOnBeforeSendingMQTT_UNSUBSCRIBE;
    OnAfterReceivingMQTT_UNSUBACK^ := @HandleOnAfterReceivingMQTT_UNSUBACK;
    OnAfterReceivingMQTT_PINGRESP^ := @HandleOnAfterReceivingMQTT_PINGRESP;
    OnBeforeSendingMQTT_DISCONNECT^ := @HandleOnBeforeSendingMQTT_DISCONNECT;
    OnAfterReceivingMQTT_DISCONNECT^ := @HandleOnAfterReceivingMQTT_DISCONNECT;
    OnBeforeSendingMQTT_AUTH^ := @HandleOnBeforeSendingMQTT_AUTH;
    OnAfterReceivingMQTT_AUTH^ := @HandleOnAfterReceivingMQTT_AUTH;
  {$ELSE}
    OnMQTTError := @HandleOnMQTTError;
    OnSendMQTT_Packet := @HandleOnSend_MQTT_Packet;
    OnBeforeMQTT_CONNECT := @HandleOnBeforeMQTT_CONNECT;
    OnAfterMQTT_CONNACK := @HandleOnAfterMQTT_CONNACK;
    OnBeforeSendingMQTT_PUBLISH := @HandleOnBeforeSendingMQTT_PUBLISH;
    OnBeforeSendingMQTT_PUBACK := @HandleOnBeforeSendingMQTT_PUBACK;
    OnAfterReceivingMQTT_PUBACK := @HandleOnAfterReceivingMQTT_PUBACK;
    OnAfterReceivingMQTT_PUBLISH := @HandleOnAfterReceivingMQTT_PUBLISH;
    OnBeforeSendingMQTT_PUBREC := @HandleOnBeforeSending_MQTT_PUBREC;
    OnAfterReceivingMQTT_PUBREC := @HandleOnAfterReceiving_MQTT_PUBREC;
    OnBeforeSendingMQTT_PUBREL := @HandleOnBeforeSending_MQTT_PUBREL;
    OnAfterReceivingMQTT_PUBREL := @HandleOnAfterReceiving_MQTT_PUBREL;
    OnBeforeSendingMQTT_PUBCOMP := @HandleOnBeforeSending_MQTT_PUBCOMP;
    OnAfterReceivingMQTT_PUBCOMP := @HandleOnAfterReceiving_MQTT_PUBCOMP;
    OnBeforeSendingMQTT_SUBSCRIBE := @HandleOnBeforeSendingMQTT_SUBSCRIBE;
    OnAfterReceivingMQTT_SUBACK := @HandleOnAfterReceivingMQTT_SUBACK;
    OnBeforeSendingMQTT_UNSUBSCRIBE := @HandleOnBeforeSendingMQTT_UNSUBSCRIBE;
    OnAfterReceivingMQTT_UNSUBACK := @HandleOnAfterReceivingMQTT_UNSUBACK;
    OnAfterReceivingMQTT_PINGRESP := @HandleOnAfterReceivingMQTT_PINGRESP;
    OnBeforeSendingMQTT_DISCONNECT := @HandleOnBeforeSendingMQTT_DISCONNECT;
    OnAfterReceivingMQTT_DISCONNECT := @HandleOnAfterReceivingMQTT_DISCONNECT;
    OnBeforeSendingMQTT_AUTH := @HandleOnBeforeSendingMQTT_AUTH;
    OnAfterReceivingMQTT_AUTH := @HandleOnAfterReceivingMQTT_AUTH;
  {$ENDIF}
end;

  
procedure PrepareManualIPAndMAC(OptionIndex: Integer);
begin
  // set mac address
  myMacAddr[0] := 0x00;
  myMacAddr[1] := 0x14;
  myMacAddr[2] := 0xA5;
  myMacAddr[3] := 0x76;
  myMacAddr[4] := 0x19;
  myMacAddr[5] := 0x3F;

  // set IP address and gateway

  case OptionIndex of
    0:
    begin
      myIpAddr[0] := 192;
      myIpAddr[1] := 168;
      myIpAddr[2] := 0;
      myIpAddr[3] := 103;

      gwIpAddr[0]  := 192;
      gwIpAddr[1]  := 168;
      gwIpAddr[2]  := 0;
      gwIpAddr[3]  := 1;
    end;

    1:
    begin
      myIpAddr[0] := 192;
      myIpAddr[1] := 168;
      myIpAddr[2] := 1;
      myIpAddr[3] := 103;

      gwIpAddr[0]  := 192;
      gwIpAddr[1]  := 168;
      gwIpAddr[2]  := 1;
      gwIpAddr[3]  := 1;
    end;

    2:
    begin
      myIpAddr[0] := 10;
      myIpAddr[1] := 101;
      myIpAddr[2] := 14;
      myIpAddr[3] := 52;

      gwIpAddr[0]  := 10;
      gwIpAddr[1]  := 101;
      gwIpAddr[2]  := 14;
      gwIpAddr[3]  := 1;
    end;

    3:
    begin
      myIpAddr[0] := 192;
      myIpAddr[1] := 168;
      myIpAddr[2] := 15;
      myIpAddr[3] := 103;

      gwIpAddr[0]  := 192;
      gwIpAddr[1]  := 168;
      gwIpAddr[2]  := 15;
      gwIpAddr[3]  := 1;
    end;

    4:
    begin
      myIpAddr[0] := 192;
      myIpAddr[1] := 168;
      myIpAddr[2] := 6;
      myIpAddr[3] := 103;

      gwIpAddr[0]  := 192;
      gwIpAddr[1]  := 168;
      gwIpAddr[2]  := 6;
      gwIpAddr[3]  := 1;
    end;
  end;  //case

  // set dns address
  dnsIpAddr[0] := 1;
  dnsIpAddr[1] := 1;
  dnsIpAddr[2] := 1;
  dnsIpAddr[3] := 1;

  // set subnet mask
  ipMask[0]    := 255;
  ipMask[1]    := 255;
  ipMask[2]    := 255;
  ipMask[3]    := 0;
end;


procedure ManualIPAndMACConfiguration(OptionIndex: Integer);
begin
  PrepareManualIPAndMAC(OptionIndex);
  Net_Ethernet_Intern_confNetwork(@ipMask, @GWIpAddr, @DnsIpAddr);
end;


var 
  AssignedIpAddr, BrokerIPAddr: array[4] of Byte;  // user IP address buffer
  TPConstsStruct: TTPConstants;
  ProcCounter: DWord;
  FirstSocket: PSOCKET_Intern_Dsc;
  ConRes: Byte;
  TempStr: string[10];
  
begin
  Delay_ms(100);
  
  InitDynOfDynOfByteToEmpty(MQTTToEthFIFO);
  InitDynOfDynOfByteToEmpty(EthToMQTTFIFO);
  InitDynArrayToEmpty(RecFIFO);
  InitDynArrayToEmpty(TempReadBuf);
  
  MM_Init;
  Init_MCU;
  InitializeTouchPanel;

  if STMPE610_Config = STMPE610_OK then
  begin
  end
  else
    while (TRUE) do ;
              {
  Delay_ms(1000);
  TFT_Fill_Screen(0);
  Calibrate();

  STMPE610_GetCalibrationConsts(@TPConstsStruct);

  TFT_Fill_Screen(0);
                 }

  TPConstsStruct.X_Min := 192;
  TPConstsStruct.X_Max := 3909;
  TPConstsStruct.Y_Min := 218;
  TPConstsStruct.Y_Max := 3846;
  TPConstsStruct.Rotate := 0;
  STMPE610_SetCalibrationConsts(@TPConstsStruct);

  TFT_Set_Pen(CL_WHITE, 1);
  TFT_Set_Brush(1, CL_LIME, 0, 0, 0, 0);
  TFT_Rectangle(0, 0, 480, 272);
  
  MQTT_Init;
  if not MQTT_CreateClient then
    AddToLog('Can''t create client...');

  InitHandlers;
  
  //Net_Ethernet_Intern_stackInitTCP;

  PrepareManualIPAndMAC(0);
  Net_Ethernet_Intern_Init(@myMacAddr, @myIpAddr, Net_Eth_Int_AUTO_NEGOTIATION or Net_Eth_Int_DEFAULT_MAC or Net_Eth_Int_SPEED_100 or Net_Eth_Int_FULLDUPLEX);
  ManualIPAndMACConfiguration(0);
  Net_Ethernet_Intern_stackInitTCP;
  
  BrokerIPAddr[0] := 192;
  BrokerIPAddr[1] := 168;
  BrokerIPAddr[2] := 0;
  BrokerIPAddr[3] := 101;
  
  FirstSocket := nil; //do not set to @socket_Intern[0]; because Net_Ethernet_Intern_connectTCP will update FirstSocket (will update the pointer)

  SomeCondition := True;
  MainCounter := 0;
  ProcCounter := 0;
  
  TFT_Set_Font(@TFT_defaultFont, CL_RED, FO_HORIZONTAL);
  TFT_Write_Text('entering main loop', 0, 250);
  
  repeat
    Inc(MainCounter);
    Net_Ethernet_Intern_doPacket;
    if HasDataToSend then
    begin
      Net_Ethernet_Intern_startSendTCP(FirstSocket);
      HasDataToSend := False;
    end;
    
    memcpy(@AssignedIpAddr, Net_Ethernet_Intern_getIpAddress(), 4);
    
    if MainCounter >= 10 then
    begin
      MainCounter := 0;
      Inc(ProcCounter);
      if ProcCounter = 65535 then
        ProcCounter := 65534;
        
      ProcessReceivedBuffer;
    end;
    
    if ProcCounter = 3900 then
    begin
      //ConRes := Net_Ethernet_Intern_connectTCP(@BrokerIPAddr, 1883, 20000, @FirstSocket);
      ConRes := Net_Ethernet_Intern_connectTCP(@BrokerIPAddr, 2358, 20000, @FirstSocket); //the connection is established, but the function can't find an available socket in the structure (altough all are available)
      
      if ConRes <> 1 then
      begin
        TFT_Write_Text('broker', 0, 0);
        ByteToStr(ConRes, TempStr);
        TFT_Write_Text(TempStr, 80, 0);
        
        AddToLog('Can''t connect to broker');
      end;
    end;

    if ProcCounter = 4000 then
      if not MQTT_CONNECT(0, 0) then
      begin
        TFT_Write_Text('MQTTConnect', 0, 20);
        AddToLog('Can''t prepare MQTTConnect packet.');
      end;
        
    if ProcCounter = 9000 then
      if not MQTT_PUBLISH(0, 0, 2) then
      begin
        TFT_Write_Text('MQTT_PUBLISH', 0, 40);
        AddToLog('Can''t prepare MQTT_PUBLISH packet.');
      end;

    if ProcCounter = 12000 then
      if not MQTT_DISCONNECT(0, 0) then
      begin
        TFT_Write_Text('MQTTDisconnect', 0, 60);
        AddToLog('Can''t prepare MQTTDisconnect packet.');
      end;
        
    if ProcCounter = 15000 then
      if Net_Ethernet_Intern_disconnectTCP(FirstSocket) = 0 then
      begin
        TFT_Write_Text('disconnect', 0, 60);
        AddToLog('Can''t disconnect.');
      end;
      
    if ProcCounter = 16000 then
    begin
      TFT_Write_Text('done cycle', 0, 80);
      AddToLog('done cycle.');
    end;
    
    if ProcCounter = 17000 then
    begin
      ProcCounter := 65534; //0;
      //TFT_Rectangle(0, 0, 480, 272);
      //MM_Init;
    end;
    

      //if not MQTT_SUBSCRIBE(0, 0) then
      //  AddToLog('Can''t prepare MQTT_SUBSCRIBE packet.');
    
      //if not MQTT_UNSUBSCRIBE(0, 0) then
      //  AddToLog('Can''t prepare MQTT_UNSUBSCRIBE packet.');

  until False;
    
  MQTT_Done;
end.